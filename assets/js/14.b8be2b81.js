(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{544:function(t,e,v){"use strict";v.r(e);var a=v(2),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"title"}),v("p",[t._v("React 与 Vue 都是很优秀的框架，优秀的框架之间大部分都是相似的")])]),t._v(" "),v("h4",{attrs:{id:"相同点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#相同点"}},[t._v("#")]),t._v(" 相同点")]),t._v(" "),v("ul",[v("li",[t._v("虚拟DOM 实现快速渲染")]),t._v(" "),v("li",[t._v("轻量级")]),t._v(" "),v("li",[t._v("响应式组件")]),t._v(" "),v("li",[t._v("服务端渲染 （vue的Nuxt， 与React的 ）")]),t._v(" "),v("li",[t._v("集成路由工具、打包工具、状态管理工具的难度低")]),t._v(" "),v("li",[t._v("优秀的社区与支持")])]),t._v(" "),v("h3",{attrs:{id:"不同点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不同点"}},[t._v("#")]),t._v(" 不同点")]),t._v(" "),v("h5",{attrs:{id:"数据绑定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据绑定"}},[t._v("#")]),t._v(" 数据绑定")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("state")]),t._v(" "),v("p",[t._v("Vue的state是可变的， React的state是不可变的。vue能直接通过this.a = 1 的方式改变数据。而React只能通过setState方法改变数据。")])]),t._v(" "),v("li",[v("p",[t._v("实现原理")]),t._v(" "),v("p",[t._v("Vue： 当像一个state添加一个新对象的时候，vue遍历其中所有的属性并转换为getter/setter 方法，来监听数据的变化，改变state的状态操作更加简洁，切不用特别的优化就能达到很好的性能。")]),t._v(" "),v("blockquote",[v("p",[t._v("缺点： 不能监测属性的添加与删除，及某些数组的更改。")])]),t._v(" "),v("p",[t._v("React 默认是通过比较引用的方式进行， 如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的render渲染")])])]),t._v(" "),v("p",[t._v("(.....待更)")]),t._v(" "),v("h5",{attrs:{id:"组件化的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组件化的区别"}},[t._v("#")]),t._v(" 组件化的区别")]),t._v(" "),v("p",[t._v("vue——支持组件化，不过是在MVVM上的扩展\nReact——本身就是组件化")]),t._v(" "),v("h4",{attrs:{id:"框架的选择"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#框架的选择"}},[t._v("#")]),t._v(" 框架的选择")]),t._v(" "),v("h5",{attrs:{id:"选择vue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#选择vue"}},[t._v("#")]),t._v(" 选择Vue")]),t._v(" "),v("ul",[v("li",[t._v("喜欢用模板搭建应用")])]),t._v(" "),v("blockquote",[v("p",[t._v("vue之前项目大多使用模板引擎，比如常用的"),v("code",[t._v("art-template")]),t._v("、"),v("code",[t._v("jade")]),t._v("， 所以Vue的上手项目较 js 编写的 React 较为容易。现在jade大多用在后端，比如 nodejs 的 express")])]),t._v(" "),v("ul",[v("li",[t._v("喜欢简单的东西，能用就行")])]),t._v(" "),v("blockquote",[v("p",[t._v("Vue 本身的数据监测不需要额外的优化，就能带来优秀的性能。使用起来简单， React的JSX与class之类的需要很多ES6方面的知识")])]),t._v(" "),v("ul",[v("li",[t._v("希望应用尽可能的小和快")])]),t._v(" "),v("h5",{attrs:{id:"选择react"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#选择react"}},[t._v("#")]),t._v(" 选择React")]),t._v(" "),v("ul",[v("li",[t._v("构建一个大型应用程序")])]),t._v(" "),v("blockquote",[v("p",[t._v("vue基于木板的应用程序看起来很好理解，跑起来也很快，但是不易于监测与测试。随着项目规模的增加，其中的技术债会越来越多，导致难以维护。模板容易出现很难注意到的运行错误，也很难测试、重构、分解。\nreact 基于js的模板有很好的分解性和DRY（Don't Rpeat Youself）复用代码。React的渲染系统的可配置性更强，还有浅渲染的特性，和React的测试工具结合起来使用，使代码的可测试性和可维护性更好。"),v("br"),t._v("\n且React的state的不可变性带来了透明度与可预测性。这对大型项目很有意义")])]),t._v(" "),v("ul",[v("li",[t._v("同时适用于Web与原生app的框架")])]),t._v(" "),v("blockquote",[v("p",[t._v("React Native 是一个使用js构建移动端的原生应用程序的库。他与React相同，只是不适用Web组件，而是使用原生组件。")])]),t._v(" "),v("blockquote",[v("p",[t._v("不过现在React Native 最近不如flutter火")])]),t._v(" "),v("ul",[v("li",[t._v("享受函数式组件的快感")])]),t._v(" "),v("blockquote",[v("p",[t._v("随着hooks的发布，函数式组件已经势不可挡。更加简洁相比于class来说，hooks使用更少的代码，且不用担心this的指针与函数的绑定问题")])]),t._v(" "),v("h5",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("p",[t._v("vue 优势：")]),t._v(" "),v("ul",[v("li",[t._v("与渲染函数的弹性选择")]),t._v(" "),v("li",[t._v("间接的语法与项目配置")]),t._v(" "),v("li",[t._v("更快的渲染速度与更小的体积")])]),t._v(" "),v("p",[t._v("react 优势：")]),t._v(" "),v("ul",[v("li",[t._v("更适合大型应用和更好的可测试性")]),t._v(" "),v("li",[t._v("web段和移动端原生app通吃（不过现在vue也有weex）")]),t._v(" "),v("li",[t._v("函数式组件 + hooks的威力谁用谁知道")])]),t._v(" "),v("p",[t._v("js多线程")])])}),[],!1,null,null,null);e.default=_.exports}}]);